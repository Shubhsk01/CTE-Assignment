use sakila;
-- Q1.Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.
-- Solution:
-- In the Sakila database, the address table might be considered to violate 1NF if it contains a field like address2
-- that is intended to store multiple values (e.g., multiple addresses in one field). To normalize it to 1NF, 
-- you would ensure that each column contains only atomic, indivisible values. 
-- If address2 stores multiple addresses, you'd split these into separate rows or create a new table to handle multiple addresses 
-- for a single entity.

-- Q2.Choose a table in Sakila and describe how you would determine whether it is in 2NF. If it violates 2NF, 
--    explain the steps to normalize it.
--  Solution:
-- The film_actor table in Sakila can be analyzed for 2NF. This table has a composite primary key (film_id, actor_id). 
-- To be in 2NF, the table must first be in 1NF, and all non-key attributes must be fully functionally dependent on the entire primary key.
-- If there were a column like actor_name, it would violate 2NF because actor_name depends only on actor_id,
-- not on the combination of film_id and actor_id. To normalize, you would remove actor_name to a separate actor table.

-- Q3. Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the 
--     steps to normalize the table to 3NF.  
-- Solution:
-- The film table might have a transitive dependency if it contained columns such as category_name instead of just a category_id.
-- Here, category_name would be transitively dependent on the category_id, which is a non-primary key.
-- To normalize the table to 3NF, you would remove the category_name and ensure that film references a category table via category_id,
-- where category_name is stored.

-- Q4.Take a specific table in Sakila and guide through the process of normalizing it from the initialu nnormalized form up to at least 2NF. 
-- Solution:
-- Consider an unnormalized rental table that contains fields like film_title, customer_name, store_address.
-- 1NF: Ensure each field contains atomic values. Remove repeating groups, so instead of storing multiple films in one row, 
-- create separate rows.
-- 2NF: Eliminate partial dependencies. Move attributes that only depend on part of the composite key 
-- (like film_title only depending on film_id) to their own tables (film table for film_title).

-- Q5.Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the  
--    actor and film_actor tables.  
-- Solution:
WITH ActorFilmCounts AS (
    SELECT
        a.actor_id,
        CONCAT(a.first_name, ' ', a.last_name) AS actor_name,
        COUNT(fa.film_id) AS film_count
    FROM
        actor a
    JOIN
        film_actor fa ON a.actor_id = fa.actor_id
    GROUP BY
        a.actor_id
)
SELECT
    actor_name,
    film_count
FROM
    ActorFilmCounts;
    
--  Q6. Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the table in Sakila.  
--  Solution:
WITH RECURSIVE CategoryHierarchy AS (
    SELECT
        category_id,
        name AS category_name,
        NULL AS parent_id
    FROM
        category
    WHERE
        parent_id IS NULL
    UNION ALL
    SELECT
        c.category_id,
        c.name,
        ch.category_id
    FROM
        category c
    JOIN
        CategoryHierarchy ch ON c.parent_id = ch.category_id
)
SELECT
    category_id,
    category_name,
    parent_id
FROM
    CategoryHierarchy;


-- Q7.Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.
-- Solution:
WITH FilmLanguage AS (
    SELECT
        f.title,
        l.name AS language_name,
        f.rental_rate
    FROM
        film f
    JOIN
        language l ON f.language_id = l.language_id
)
SELECT
    title,
    language_name,
    rental_rate
FROM
    FilmLanguage;
 
-- Q8.Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and
--    payment tables.  

-- Solution:
WITH CustomerRevenue AS (
    SELECT
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        SUM(p.amount) AS total_revenue
    FROM
        customer c
    JOIN
        payment p ON c.customer_id = p.customer_id
    GROUP BY
        c.customer_id
)
SELECT
    customer_name,
    total_revenue
FROM
    CustomerRevenue
ORDER BY
    total_revenue DESC;
    
    
--  Q9. Utilize a CTE with a window function to rank films based on their rental duration from the rental table.

--  Solution:
WITH FilmDurationRank AS (
    SELECT
        f.film_id,
        f.title,
        DATEDIFF(r.return_date, r.rental_date) AS rental_duration,
        RANK() OVER (ORDER BY DATEDIFF(r.return_date, r.rental_date) DESC) AS duration_rank
    FROM
        film f
    JOIN
        inventory i ON f.film_id = i.film_id
    JOIN
        rental r ON i.inventory_id = r.inventory_id
)
SELECT
    title,
    rental_duration,
    duration_rank
FROM
    FilmDurationRank;
    
 
--  Q10.Create a CTE to list customers who have made more than two rentals,and then join this CTE with the customer table to retrieve
--      additional customer details.

-- Solution:
WITH FrequentRenters AS (
    SELECT
        r.customer_id,
        COUNT(r.rental_id) AS rental_count
    FROM
        rental r
    GROUP BY
        r.customer_id
    HAVING
        COUNT(r.rental_id) > 2
)
SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    fr.rental_count
FROM
    customer c
JOIN
    FrequentRenters fr ON c.customer_id = fr.customer_id;
    
    
-- Q11.Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from the rental table.

-- Solution:
WITH MonthlyRentals AS (
    SELECT
        DATE_FORMAT(r.rental_date, '%Y-%m') AS month_year,
        COUNT(r.rental_id) AS total_rentals
    FROM
        rental r
    GROUP BY
        DATE_FORMAT(r.rental_date, '%Y-%m')
)
SELECT
    month_year,
    total_rentals
FROM
    MonthlyRentals
ORDER BY
    month_year ASC;
    
    
-- Q12.Use a CTE to pivot the data from the payment table to display the total payments made by each customer in separate columns
--     for different payment methods.

-- Solution:
WITH PaymentPivot AS (
    SELECT
        c.customer_id,
        concat(c.first_name," ",c.last_name) as customer,
        SUM(p.amount) AS total_payment
        
    FROM
        customer c
    JOIN
        payment p ON c.customer_id = p.customer_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name
)
SELECT
    customer,
    total_payment
    
FROM
    PaymentPivot;
-- ther is no payment method defined in sakila database
           
     
-- Q13.Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.

-- Solution:
WITH ActorPairs AS (
    SELECT
        fa1.actor_id AS actor_id_1,
        fa2.actor_id AS actor_id_2,
        fa1.film_id
    FROM
        film_actor fa1
    JOIN
        film_actor fa2 ON fa1.film_id = fa2.film_id
    WHERE
        fa1.actor_id < fa2.actor_id
)
SELECT
    a1.first_name AS actor_1_first_name,
    a1.last_name AS actor_1_last_name,
    a2.first_name AS actor_2_first_name,
    a2.last_name AS actor_2_last_name,
    ap.film_id
FROM
    ActorPairs ap
JOIN
    actor a1 ON ap.actor_id_1 = a1.actor_id
JOIN
    actor a2 ON ap.actor_id_2 = a2.actor_id;
    
    
-- Q14.Implement a recursive CTE to find all employees in the staff table who report to a specific manager,
--     considering the reports_to column.   

-- Solution:
WITH RECURSIVE StaffHierarchy AS (
    SELECT
        staff_id,
        concat(first_name," " ,last_name) as employee
        
    FROM
        staff
 )
SELECT
    staff_id,
    employee
FROM
    StaffHierarchy;
    
-- This querry shows all the employee in staff table and these employee not report to any of the manager because there is not any 
-- manager or manager id column or table in this sakila database       
